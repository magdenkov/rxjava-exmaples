import rx.Observable;
import rx.schedulers.Schedulers;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class Library {
    public boolean someLibraryMethod() throws ExecutionException, InterruptedException {
        System.out.println("current main thread before future " + Thread.currentThread());

        Future<String> ss = Observable.just("1")
                .subscribeOn(Schedulers.newThread())
                .map(s -> {
                    try {
                        Thread.currentThread().sleep(4000l);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("Current thread in ObservableFuture " + Thread.currentThread());
                    return s + s;
                })
                .toSingle().toBlocking().toFuture();

        System.out.println("Current main thread after first future 1111" + Thread.currentThread());


        Future<String> ss2 = Observable.just("2")
                .subscribeOn(Schedulers.newThread())
                .map(s -> {

                    try {
                        Thread.currentThread().sleep(1000l);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("Current thread in ObservableFuture 22222 " + Thread.currentThread());
                    return s + s;
                })

                .toSingle().toBlocking().toFuture();

        System.out.println("Current main thread  after second fuutre" + Thread.currentThread());

        System.out.println("Results on Second" + ss2.get());
        System.out.println("Results on first" + ss.get());
        return true;
    }


    public static void main(String[] args) throws ExecutionException, InterruptedException {



//        ss.get();
    }
}
